#version 450

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Amplitude {
	float amp;
};

struct Vertex {
	vec3 pos;
	vec3 normal;
};

struct Triangle {
	Vertex vertices[3];
};

layout(std430, set = 0, binding = 0) buffer AmpVolume {
   Amplitude ampVolume[ ];
};

layout(std430, set = 1, binding = 0) buffer TriangleBuffer {
	Triangle triangles[ ];	
};

layout(std430, set = 2, binding = 0) buffer MidpointBuffer {
	float midpoints[ ];	
};

layout(std430, set = 3, binding = 0) buffer SizesBuffer {
	uint sizes[ ];	
};

layout(set = 4, binding=0) uniform Transform {
    mat4 M;
    mat4 V;
    mat4 P;
    vec3 cameraPos;
	vec3 cameraFront;
} transform;

vec3 sourcePos = vec3(0.0);

int xExtent = 372;
int yExtent = 155;
int zExtent = 228;

float minX = 1920.95;
float minY = 1429.43;
float minZ = 1182.81;

float perpDist(vec3 p1, vec3 p2, vec3 cell) {
	vec3 AB = p2-p1;
	vec3 AP = cell-p1;

	return ((length(cross(AB, AP)))/length(AB));
}

float fraction(float num) {
	if (num > 0) 
		return num - floor(num);
	else 
		return num - ceil(num);
}

float rand(vec3 co){
    return (fraction(sin(dot(co, vec3(12.9898, 78.233, 103.5392))) * 43758.5453));
}

vec3 randVec3(vec3 co) {
	return normalize(vec3(rand(co.xyz), rand(co.yzx), rand(co.zxy)));
}

#define PI 3.14159265359

vec3 randomSpherePoint(vec3 rand) {
  float ang1 = (rand.x + 1.0) * PI; // [-1..1) -> [0..2*PI)
  float u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)
  float u2 = u * u;
  float sqrt1MinusU2 = sqrt(1.0 - u2);
  float x = sqrt1MinusU2 * cos(ang1);
  float y = sqrt1MinusU2 * sin(ang1);
  float z = u;
  return normalize(vec3(x, y, z));
}

int rayTriangleIntersection (vec3 start, vec3 end, Triangle T) {

	vec3 edge1 = T.vertices[1].pos - T.vertices[0].pos;
	vec3 edge2 = T.vertices[2].pos - T.vertices[0].pos;
	vec3 ray_vector = end - start;
	vec3 ray_cross_e2 = cross(ray_vector, edge2);
	float det = dot(edge1, ray_cross_e2);

	if (det > -0.000001 && det < 0.000001) {
		return 0;
	}

	float inv_det = 1.0/det;
	vec3 s = start - T.vertices[0].pos;
	float u = inv_det * dot(s, ray_cross_e2);

	if ((u < 0 && abs(u) > 0.000001) || (u > 1 && abs(u-1) > 0.000001))
        return 0;

	vec3 s_cross_e1 = cross(s, edge1);
    float v = inv_det * dot(ray_vector, s_cross_e1);

	if ((v < 0 && abs(v) > 0.000001) || (u + v > 1 && abs(u + v - 1) > 0.000001))
        return 0;

	float t = inv_det * dot(edge2, s_cross_e1);
	float segmentLength = length(end - start);

    if (t < 0.0 || t > segmentLength) 
    {
        return 0;
    }
    
    return 1;
}

int Collision(vec3 start, vec3 end, ivec3 ID) {

	int flatID = ID.x + ID.y * 8 + ID.z * 64;

	if (ID == ivec3(gl_GlobalInvocationID)) {
		return -1;
	}

	int SizeBefore = 0;
	int Size = int(sizes[flatID]);

	if (Size == 0) {
		return -2;
	}

	for (uint i=0; i<flatID; i++) {
		SizeBefore += int(sizes[i]);
	}

	for (int i = SizeBefore-1; i < SizeBefore+Size; i++) {
		Triangle T = triangles[i];

		if (rayTriangleIntersection (start, end, T) == 1) {
			return i;
		}

	}

	return 0;
}

ivec3 getCellID(vec3 pos) {
	ivec3 cellID;

	cellID = ivec3((pos / (vec3(xExtent, yExtent, zExtent) * 10.0)) * 8.0);
	
	return cellID;
}

int checkModelExtent(vec3 pos) {
	
	if (pos.x > float(xExtent)*10.0-minX || pos.x < -minX) {
		return 1;
	}
	if (pos.y > float(yExtent)*10.0-minY || pos.y < -minY) {
		return 2;
	}
	if (pos.z > float(zExtent)*10.0-minZ || pos.z < -minZ) {
		return 3;
	}

	return 0;
}

void main() {
	
	sourcePos = vec3(xExtent, yExtent, zExtent) * 5.0 - vec3(minX, minY, minZ);

	ivec3 sourceCell = getCellID(sourcePos);

	vec3 rayPos = vec3(gl_GlobalInvocationID) * 10.0 - vec3(minX, minY, minZ) + vec3(5.0);

	vec3 accum = vec3(0);

	for (int i=0; i<1; i++) {

		int depth = 0;	

		vec3 rayDir = normalize((sourcePos - rayPos));// + randomSpherePoint(randVec3(vec3(i, i*27, i+30))));

		ivec3 currentCell = ivec3(getCellID(rayPos + vec3(minX, minY, minZ)));

		while (checkModelExtent(rayPos) == 0 && depth < 1000) {

			ivec3 cellID = getCellID(rayPos + vec3(minX, minY, minZ));

			if (cellID == currentCell) {
				depth++;
				rayPos = rayPos + 10.0*rayDir;
				continue;
			}
			else {
				currentCell = cellID;
			}

			int collide = Collision(rayPos, sourcePos, cellID);

			if (collide > 0) {
				
				ivec3 ampCellID = ivec3(gl_GlobalInvocationID);
				int ampFlatID = ampCellID.x + ampCellID.y * xExtent + ampCellID.z * xExtent * yExtent;

				ampVolume[ampFlatID].amp = 0;

				break;
			}

			if (length(sourcePos - rayPos) < 1.0) {

				ivec3 ampCellID = ivec3(gl_GlobalInvocationID);
				int ampFlatID = ampCellID.x + ampCellID.y * xExtent + ampCellID.z * xExtent * yExtent;

				ampVolume[ampFlatID].amp = 1.0;

				break;

			}
			depth++;

			rayPos = rayPos + 1.0*rayDir;

		}
	}
}
