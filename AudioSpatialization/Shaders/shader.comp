#version 450

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Amplitude {
	float amp;
};

struct Vertex {
	vec4 pos;
	vec4 normal;
};

struct Triangle {
	Vertex vertices[3];
};

struct OctreeNode {
	vec3 Low;
	vec3 High;
};

struct Octree {
	OctreeNode elements[512];
}octree;

layout(std430, set = 0, binding = 0) buffer AmpVolume {
   Amplitude ampVolume[ ];
};

layout(std430, set = 1, binding = 0) buffer TriangleBuffer {
	Triangle triangles[ ];	
};

layout(std430, set = 2, binding = 0) buffer MidpointBuffer {
	float midpoints[ ];	
};

layout(std430, set = 3, binding = 0) buffer SizesBuffer {
	uint sizes[ ];	
};

layout(set = 4, binding=0) uniform Transform {
    mat4 M;
    mat4 V;
    mat4 P;
    vec3 cameraPos;
	vec3 cameraFront;
} transform;

vec3 sourcePos = vec3(0.0);

int xExtent = 372;
int yExtent = 155;
int zExtent = 228;

float minX = 1920.95;
float minY = 1429.43;
float minZ = 1182.81;

float ClosestDepth;
Triangle ClosestTriangle;
vec3 startPos;
vec3 rayDir;
float Collision_t;

float perpDist(vec3 p1, vec3 p2, vec3 cell) {
	vec3 AB = p2-p1;
	vec3 AP = cell-p1;

	return ((length(cross(AB, AP)))/length(AB));
}

float fraction(float num) {
	if (num > 0) 
		return num - floor(num);
	else 
		return num - ceil(num);
}

float rand(vec3 co){
    return ((abs(fraction(sin(dot(co, vec3(12.9898, 78.233, 103.5392))) * 43758.5453))/2.0)+0.5);
}

vec3 randVec3(vec3 co) {
	return normalize(vec3(rand(co.xyz), rand(co.yzx), rand(co.zxy)));
}

#define PI 3.14159265359

vec3 randomSpherePoint(vec3 rand) {
  float ang1 = (rand.x + 1.0) * PI; // [-1..1) -> [0..2*PI)
  float u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)
  float u2 = u * u;
  float sqrt1MinusU2 = sqrt(1.0 - u2);
  float x = sqrt1MinusU2 * cos(ang1);
  float y = sqrt1MinusU2 * sin(ang1);
  float z = u;
  return normalize(vec3(x, y, z));
}

float rayTriangleIntersection (vec3 start, vec3 end, Triangle T) {

    vec3 edge1 = T.vertices[1].pos.xyz - T.vertices[0].pos.xyz;
	vec3 edge2 = T.vertices[2].pos.xyz - T.vertices[0].pos.xyz;
	vec3 ray_vector = end - start;
	vec3 ray_cross_e2 = cross(ray_vector, edge2);
	float det = dot(edge1, ray_cross_e2);

	vec3 Normal = normalize((T.vertices[0].normal.xyz + T.vertices[1].normal.xyz + T.vertices[2].normal.xyz)/3.0);

	if (det > -0.000001 && det < 0.000001) {
		return 0;
	}

	if(dot(Normal, normalize(ray_vector)) > 0) {
		return 0;
	}

	float inv_det = 1.0/det;
	vec3 s = start - T.vertices[0].pos.xyz;
	float u = inv_det * dot(s, ray_cross_e2);

	if ((u < 0 && abs(u) > 0.000001) || (u > 1 && abs(u-1) > 0.000001))
        return 0;

	vec3 s_cross_e1 = cross(s, edge1);
    float v = inv_det * dot(ray_vector, s_cross_e1);

	if ((v < 0 && abs(v) > 0.000001) || (u + v > 1 && abs(u + v - 1) > 0.000001))
        return 0;

	float t = inv_det * dot(edge2, s_cross_e1);
	float segmentLength = length(end - start);

    if (t < 0.0) 
    {
        return 0;
    }
    
	Collision_t = t;

    return t;

}

ivec3 getAmpCellID(vec3 pos) {
	ivec3 cellID;

	cellID = ivec3(pos/10.0);
	
	return cellID;
}

int Collision(vec3 start, vec3 end, ivec3 ID) {

	int flatID = ID.x + ID.y * 8 + ID.z * 64;

	int SizeBefore = 0;
	int Size = int(sizes[flatID]);

	if (Size == 0) {
		return 0;
	}

	for (uint i=0; i<flatID; i++) {
		SizeBefore += int(sizes[i]);
	}

	for (int i = SizeBefore-1; i < SizeBefore+Size; i++) {
		Triangle T = triangles[i];

		vec3 Centroid = (T.vertices[0].pos.xyz + T.vertices[1].pos.xyz + T.vertices[2].pos.xyz)/3.0;

		if (length(Centroid - start) > length(end - start)) {
			continue;
		}

		if (getAmpCellID(Centroid + vec3(minX, minY, minZ)) == ivec3(gl_GlobalInvocationID.xyz)) {
			continue;
		}
		if (getAmpCellID(T.vertices[0].pos.xyz + vec3(minX, minY, minZ)) == ivec3(gl_GlobalInvocationID.xyz)) {
			continue;
		}
		if (getAmpCellID(T.vertices[1].pos.xyz + vec3(minX, minY, minZ)) == ivec3(gl_GlobalInvocationID.xyz)) {
			continue;
		}
		if (getAmpCellID(T.vertices[2].pos.xyz + vec3(minX, minY, minZ)) == ivec3(gl_GlobalInvocationID.xyz)) {
			continue;
		}

		float t = rayTriangleIntersection (start, end, T);

		if (t > 0) {
			if (length(Centroid - start) < ClosestDepth) {
				ClosestDepth = length(Centroid - start);
				ClosestTriangle = T;
				startPos = startPos + t * rayDir;
				vec3 normal = (T.vertices[0].normal.xyz + T.vertices[1].normal.xyz + T.vertices[2].normal.xyz)/3.0;
				rayDir = reflect(rayDir, normal);
			}
			return i;
		}

	}

	return 0;
}

ivec3 getCellID(vec3 pos) {
	ivec3 cellID;

	cellID = ivec3((pos / (vec3(xExtent, yExtent, zExtent) * 10.0)) * 8.0);
	
	return cellID;
}


int checkModelExtent(vec3 pos) {
	
	if (pos.x > float(xExtent)*10.0-minX || pos.x < -minX) {
		return 1;
	}
	if (pos.y > float(yExtent)*10.0-minY || pos.y < -minY) {
		return 2;
	}
	if (pos.z > float(zExtent)*10.0-minZ || pos.z < -minZ) {
		return 3;
	}

	return 0;
}

int rayBoxIntersection(vec3 Low, vec3 High, vec3 rayOrigin, vec3 rayDir) {

	vec3 tmin, tmax;

	tmin = (Low - rayOrigin)/rayDir;
	tmax = (High - rayOrigin)/rayDir;

	vec3 tclose, tfar;

	tclose.x = min(tmin.x, tmax.x);
	tfar.x = max(tmin.x, tmax.x);
	tclose.y = min(tmin.y, tmax.y);
	tfar.y = max(tmin.y, tmax.y);
	tclose.z = min(tmin.z, tmax.z);
	tfar.z = max(tmin.z, tmax.z);

	float t_close = max(tclose.x, max(tclose.y, tclose.z));
	float t_far = min(tfar.x, min(tfar.y, tfar.z));

	if (t_close <= t_far && t_far > 0) {
		return 1;
	}

	return 0;
}

int traverseOctree(vec3 rayOrigin, vec3 rayDir, vec3 sourcePos) {

	vec3 globalMin = -1 * vec3(minX, minY, minZ);
	vec3 globalMax = vec3(xExtent, yExtent, zExtent)*10.0 - vec3(minX, minY, minZ);

	vec3 Extent = vec3(xExtent, yExtent, zExtent)*10.0;

	int sourceCollision = 0;

	for (int i=0 ; i<8; i++) {
		vec3 depth_1_min;
		vec3 depth_1_max;

		depth_1_min.x = globalMin.x + (i%2) * Extent.x/2.0;
		depth_1_min.y = globalMin.y + ((int(i/2))%2) * Extent.y/2.0;
		depth_1_min.z = globalMin.z + (int(i/4)%2) * Extent.z/2.0;

		depth_1_max = depth_1_min + Extent/2.0;

		if (rayBoxIntersection(depth_1_min, depth_1_max, rayOrigin, rayDir) == 0) {
			continue;
		}

		for (int j=0; j<8; j++) {
			vec3 depth_2_min;
			vec3 depth_2_max;

			depth_2_min.x = depth_1_min.x + (j%2) * Extent.x/4.0;
			depth_2_min.y = depth_1_min.y + ((int(j/2))%2) * Extent.y/4.0;
			depth_2_min.z = depth_1_min.z + (int(j/4)%2) * Extent.z/4.0;

			depth_2_max = depth_2_min + Extent/4.0;

			if (rayBoxIntersection(depth_2_min, depth_2_max, rayOrigin, rayDir) == 0) {
				continue;
			}

			for (int k=0; k<8; k++) {
				vec3 depth_3_min;
				vec3 depth_3_max;

				depth_3_min.x = depth_2_min.x + (k%2) * Extent.x/8.0;
				depth_3_min.y = depth_2_min.y + ((int(k/2))%2) * Extent.y/8.0;
				depth_3_min.z = depth_2_min.z + (int(k/4)%2) * Extent.z/8.0;

				depth_3_max = depth_3_min + Extent/8.0;
				
				if (rayBoxIntersection(depth_3_min, depth_3_max, rayOrigin, rayDir) == 1) {
					
					vec3 cellMid = (depth_3_min + depth_3_max)/2.0 + vec3(minX, minY, minZ);

					ivec3 cellID = getCellID(cellMid);

					if (cellID == getCellID(sourcePos + vec3(minX, minY, minZ))) {
						sourceCollision = 1;
					}

					int collided = Collision(rayOrigin, sourcePos, cellID);

					if (collided > 0) {
						return 1;
					}
				}
			}
		}
	}

	if (sourceCollision == 1) {
		return 0;
	}

	return 0;

}

void main() {

	vec3 sourcePos = (vec3(xExtent, yExtent, zExtent)*10.0)/2.0 - vec3(minX, minY, minZ) + vec3(5.0);

	vec3 ampPos = vec3(gl_GlobalInvocationID) * 10.0 + vec3(5.0) - vec3(minX, minY, minZ);

	rayDir = normalize(sourcePos - ampPos);

	ClosestDepth = length(sourcePos - ampPos);

	float visibility = 1.0;

	startPos = ampPos;

	for (int i=0; i<1; i++) {
		
		visibility -= traverseOctree(startPos, rayDir, sourcePos);
	
	}

	ivec3 ampCellID = ivec3(gl_GlobalInvocationID);
	int ampFlatID = ampCellID.x + ampCellID.y * xExtent + ampCellID.z * xExtent * yExtent;
	ampVolume[ampFlatID].amp = visibility;

}