#version 450

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Amplitude {
	float amp;
};

struct Vertex {
	vec3 pos;
	vec3 normal;
};

struct Triangle {
	Vertex vertices[3];
};

layout(std430, set = 0, binding = 0) buffer AmpVolume {
   Amplitude ampVolume[ ];
};

layout(std430, set = 1, binding = 0) buffer TriangleBuffer {
	Triangle triangles[ ];	
};

layout(std430, set = 2, binding = 0) buffer MidpointBuffer {
	float midpoints[ ];	
};

layout(std430, set = 3, binding = 0) buffer SizesBuffer {
	uint sizes[ ];	
};

layout(set = 4, binding=0) uniform Transform {
    mat4 M;
    mat4 V;
    mat4 P;
    vec3 cameraPos;
	vec3 cameraFront;
} transform;

vec3 sourcePos = vec3(0.0, 5.0, 0.0);

float fov = 45;

vec3 CellDim;

int xExtent = 372;
int yExtent = 155;
int zExtent = 228;

float minX = 1920.95;
float minY = 1429.43;
float minZ = 1182.81;

float perpDist(vec3 p1, vec3 p2, vec3 cell) {
	vec3 AB = p2-p1;
	vec3 AP = cell-p1;

	return ((length(cross(AB, AP)))/length(AB));
}

float rand(vec3 co){
    return fract(sin(dot(co, vec3(12.9898, 78.233, 103.5392))) * 43758.5453);
}

int rayTriangleIntersection (vec3 start, vec3 end, Triangle T) {

	vec3 BCenter = (T.vertices[0].pos + T.vertices[1].pos + T.vertices[2].pos) / 3.0;

	float largestDist = 0;
	
	for (int i=0; i<3; i++) {
		if (length(BCenter - T.vertices[i].pos) > largestDist) {
			largestDist = length(BCenter - T.vertices[i].pos);
		}
	}

	if (perpDist(start, end, BCenter) < largestDist) {
		return 1;
	}
	
	return 0;
	
}

int Collision(vec3 start, vec3 end, ivec3 ID) {

	int flatID = ID.x + ID.y * 8 + ID.z * 64;

	int SizeBefore = 0;
	int Size = int(sizes[flatID]);

	for (uint i=0; i<flatID; i++) {
		SizeBefore += int(sizes[i]);
	}

	if (Size == 0) {
		return 0;
	}

	for (int i = SizeBefore-1; i < SizeBefore+Size; i++) {
		Triangle T = triangles[i];

		if (rayTriangleIntersection (start, end, T) == 1) {
			return 1;
		}

	}

	return 0;
}

ivec3 getCellID(vec3 pos) {
	ivec3 cellID;

	cellID.x = int((pos.x/float(xExtent))*8.0);
	cellID.y = int((pos.y/float(yExtent))*8.0);
	cellID.z = int((pos.z/float(zExtent))*8.0);
	
	return cellID;
}

void main() {

	vec3 pos = vec3(gl_GlobalInvocationID.xyz)*10.0 - vec3(minX, minY, minZ);

	uint xIndex = 0;
	uint yIndex = 0;
	uint zIndex = 0;

	ivec3 sourceID = ivec3(0);

	CellDim = vec3(midpoints[1] - midpoints[0], midpoints[10] - midpoints[9], midpoints[19] - midpoints[18]);

	for (int i = 0; i < 8; i++) {
		if (pos.x > midpoints[i] && pos.x < midpoints[i+1]) {
			xIndex = i;
		}
		if (sourcePos.x > midpoints[i] && sourcePos.x < midpoints[i+1]) {
			sourceID.x = i;
		}
	}	  
	for (int i = 9; i < 17; i++) {
		if (pos.y > midpoints[i] && pos.y < midpoints[i+1]) {
			yIndex = i-9;
		}
		if (sourcePos.y > midpoints[i] && sourcePos.y < midpoints[i+1]) {
			sourceID.y = i-9;
		}
	}
	for (int i = 18; i < 26; i++) {
		if (pos.z > midpoints[i] && pos.z < midpoints[i+1]) {
			zIndex = i-18;
		}
		if (sourcePos.z > midpoints[i] && sourcePos.z < midpoints[i+1]) {
			sourceID.z = i-18;
		}
	}

	uint flatID = xIndex + yIndex * 8 + zIndex * 8 * 8;

	ivec3 ID = ivec3(xIndex, yIndex, zIndex); 

	vec3 voxelCenter = vec3((midpoints[xIndex] + midpoints[xIndex+1])/2.0, (midpoints[yIndex+9] + midpoints[yIndex+9+1])/2.0, (midpoints[zIndex+18] + midpoints[zIndex+18+1])/2.0);

	uint AmpFlatID = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 372 + gl_GlobalInvocationID.z * 372 * 155;

	//if (dot(normalize(transform.cameraPos - voxelCenter), transform.cameraFront) < 0.7) {
	//	ampVolume[AmpFlatID].amp = 0.0;
	//	return;
	//}

	//int collision = DDA(sourcePos, voxelCenter, ID, sourceID);

	//if (collision == 1) {
	//	ampVolume[AmpFlatID].amp = 1;
	//	return;
	//}

	vec3 clampedGID = vec3(gl_GlobalInvocationID.x/float(xExtent), gl_GlobalInvocationID.y/float(yExtent), gl_GlobalInvocationID.z/float(zExtent)) * 8.0;
	vec3 binnedGID = vec3(int(clampedGID.x), int(clampedGID.y), int(clampedGID.z));

	float dist = length(sourcePos - pos);
	float step = dist/10.0;

	ivec3 currentCell = sourceID;
	int cellsTravelled = 0;
	int Collided = 0;

	for (uint i=0; i<10; i++) {
		vec3 rayPos = sourcePos + i*step*normalize(pos - sourcePos);
		
		ivec3 cellID = getCellID((rayPos + vec3(minX, minY, minZ))/10.0);

		if (cellID == currentCell) {
			continue;
		}

		cellsTravelled++;
		currentCell = cellID;

		if (Collision(sourcePos, pos, cellID) == 1) {
			Collided = 1;
			break;
		}

	}

	ampVolume[AmpFlatID].amp =  Collided; //sizes[flatID];
	return;

}
